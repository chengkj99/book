# 一些重要的编程思想

## 依赖注入（DI）和控制反转（IOC）

在开发一个功能或项目，我们往往会需要多个对象共同完成。在依赖注入之前，我们如果在 A 对象中要使用另一个 B 对象，需要在 A 对象中主动的创建 B 对象；

```js
class A {
  const b = new B();
}
```

此时，在 A 对象和 B 对象之间，就产生了耦合，在 A 对象中，要控制 B 对象的创建和销毁；此时如果是管理一个对象还好，如果在 A 对象中管理多个甚至十几个对象的时候，A 对象的负担就很重了；`依赖注入`就是为了解决这个问题。

```js
class A {
  constructor(private b: B) {
    // ...
  }
}
```

以上可见，在对象 A 并没有创建对象 B，对象 A 仅仅是依赖了 B 对象，B 对象能够被「神奇的」注入到依赖它的 A 对象中，这就是`依赖注入`。

`依赖注入`让对象 A 尽管依赖 B 对象和使用 B 对象，不需要关心 B 对象的创建和销毁，只管使用即可，这样一来，开发者仅仅关心使用哪些对象资源，完成业务开发，不需要关心这些对象资源由谁创建和管理了，可以有效的提高代码的可维护性和对象重用效率。

那么谁来关心 B 对象的创建呢，答案是交给「第三方管理」，这个第三方就是`IoC(Inversion of Control) 容器`。

在这里 IOC 容器的作用：

1. 创建 A 对象和 B 对象的实例
2. 检查 A 对象和 B 对象有依赖对象需要注入
3. 检查到 A 对象依赖了 B 对象，将 B 对象实例注入到 A 对象
4. 由容器来管理 A 对象和 B 对象的生命周期

IOC 容器来负责对象的创建和销毁，如果 A 对象依赖了 B 对象，`IOC 容器`负责将对象实例注入进去，让 A 对象使用。这样对象和对象之间就耦合度就很低了，每一个对象尽管依赖和使用其他对象即可。
